<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#EB6237"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-10-13T07:42:44.1918831"><title>Patching Code | Content Warning Modding Wiki</title><script type="application/json" id="virtual-toc-data">[{"id":"introduction","level":0,"title":"Introduction","anchor":"#introduction"},{"id":"monomod","level":0,"title":"MonoMod","anchor":"#monomod"},{"id":"harmony","level":0,"title":"Harmony","anchor":"#harmony"},{"id":"conclusion","level":0,"title":"Conclusion","anchor":"#conclusion"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b419/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Patching Code | Content Warning Modding Wiki"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Content Warning Modding Wiki Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/cwmodding.wiki/1.0/patching-code.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Patching Code | Content Warning Modding Wiki"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/cwmodding.wiki/1.0/patching-code.html#webpage",
    "url": "writerside-documentation/cwmodding.wiki/1.0/patching-code.html",
    "name": "Patching Code | Content Warning Modding Wiki",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentationcwmodding.wiki/#website",
    "url": "writerside-documentationcwmodding.wiki/",
    "name": "Content Warning Modding Wiki Help"
}</script><!-- End Schema.org --></head><body data-id="Patching-Code" data-main-title="Patching Code" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Modding-Topics.md|Modding Topics///Fundamentals.md|Fundamentals"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Content Warning Modding Wiki 1.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Patching-Code" id="Patching-Code.md">Patching Code</h1><aside class="prompt" data-type="tip" data-title="" id="fz4kf2_3"><p id="fz4kf2_8"><span class="control" id="fz4kf2_10">INFO</span></p><p id="fz4kf2_9">This tutorial is taken and adapted from the <a href="https://lethal.wiki" id="fz4kf2_11" data-external="true" rel="noopener noreferrer">Lethal Company Modding Wiki</a>. For more resources refer to that.</p></aside><section class="chapter"><h2 id="introduction" data-toc="introduction">Introduction</h2><p id="fz4kf2_12">When modding games, you will often need to make modifications to the original code. Thankfully, this is fairly easy thanks to <span class="control" id="fz4kf2_17">MonoMod</span> and <span class="control" id="fz4kf2_18">Harmony</span>. These allow us to things such as:</p><ul class="list _bullet" id="fz4kf2_13"><li class="list__item" id="fz4kf2_19"><p><span class="control" id="fz4kf2_21">Replace and modify</span> original methods</p></li><li class="list__item" id="fz4kf2_20"><p><span class="control" id="fz4kf2_22">Run our code before and/or after</span> the original methods</p></li></ul><p id="fz4kf2_14">MonoMod and Harmony are incredibly powerful tools, and with them, we can do nearly anything we want. They differ in the ways they are used, and it really just comes up to preference which one you should use.</p><p id="fz4kf2_15">However, keep in mind that you aren't restricted to using only one of these tools, as the version of Harmony we are using is <a href="https://github.com/BepInEx/HarmonyX" id="fz4kf2_23" data-external="true" rel="noopener noreferrer">HarmonyX</a>, which is Harmony built on top of <span class="control" id="fz4kf2_24">MonoMod</span> so there will not be any conflicts.</p><aside class="prompt" data-type="tip" data-title="" id="fz4kf2_16"><p id="fz4kf2_25"><span class="control" id="fz4kf2_27">NOTE</span></p><p id="fz4kf2_26">In this and the following articles, we use &quot;patching&quot; and &quot;hooking&quot; to refer to the act of running our code before and after the original method, or directly modifying the original method.</p></aside></section><section class="chapter"><h2 id="monomod" data-toc="monomod">MonoMod</h2><aside class="prompt" data-type="tip" data-title="" id="fz4kf2_28"><p id="fz4kf2_43"><span class="control" id="fz4kf2_45">INFO</span></p><p id="fz4kf2_44">The version of <span class="control" id="fz4kf2_46">MonoMod</span> we use with BepInEx is considered <span class="control" id="fz4kf2_47">legacy</span>, which is important to know when looking up <a href="https://lethal.wiki/dev/fundamentals/patching-code/monomod-documentation" id="fz4kf2_48" data-external="true" rel="noopener noreferrer">MonoMod Documentation</a>.</p></aside><p id="fz4kf2_29">MonoMod is arguably easier to use than Harmony in most cases thanks to its <code class="code" id="fz4kf2_49">MMHOOK</code> assemblies generated by <span class="control" id="fz4kf2_50">MonoMod.RuntimeDetour.HookGen</span>.</p><p id="fz4kf2_30">If you've ever wondered what <a href="https://thunderstore.io/c/content-warning/p/Hamunii/AutoHookGenPatcher/" id="fz4kf2_51" data-external="true" rel="noopener noreferrer">AutoHookGenPatcher</a> is, it generates these files from its target assemblies using MonoMod's HookGen API. For example, <code class="code" id="fz4kf2_52">Assembly-CSharp.dll</code> is the assembly that contains most of the game's code, and HookGen generates a file from it called <code class="code" id="fz4kf2_53">MMHOOK_Assembly-CSharp.dll</code>, which provides us an easy way to Hook any non-generic method as if it were an event.</p><p id="fz4kf2_31">To use these events, we can for example do the following:</p><div class="code-block" data-lang="csharp">
// Subscribe to the event, applying our patch
On.Player.Update += MyPatch;
</div><aside class="prompt" data-type="note" data-title="" id="fz4kf2_33"><p id="fz4kf2_54"><span class="control" id="fz4kf2_57">INFO</span></p><p id="fz4kf2_55"><code class="code" id="fz4kf2_58">Player</code> is the class/script that controls all players in Content Warning. It is defined under the default namespace.</p><p id="fz4kf2_56"><code class="code" id="fz4kf2_59">Update</code> is a method which executes on every frame, which <code class="code" id="fz4kf2_60">Player</code> implements. This is a method provided by the <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html" id="fz4kf2_61" data-external="true" rel="noopener noreferrer">MonoBehaviour</a> class in Unity.</p></aside><aside class="prompt" data-type="tip" data-title="" id="fz4kf2_34"><p id="fz4kf2_62"><span class="control" id="fz4kf2_64">TIP</span></p><p id="fz4kf2_63">All <code class="code" id="fz4kf2_65">MMHOOK</code> Hooks are under the <code class="code" id="fz4kf2_66">On</code> and <code class="code" id="fz4kf2_67">IL</code> namespaces. The <code class="code" id="fz4kf2_68">On</code> namespace contains normal Hooks which allow running our code before and after the original method, while the <code class="code" id="fz4kf2_69">IL</code> namespace contains <span class="control" id="fz4kf2_70">ILHooks</span> which allow us to modify the original methods on the <span class="control" id="fz4kf2_71">IL</span> (or <span class="control" id="fz4kf2_72">CIL</span>) level, which is what C# compiles to.</p></aside><p id="fz4kf2_35">This will add our method <code class="code" id="fz4kf2_73">MyPatch</code> as an event handler for the <code class="code" id="fz4kf2_74">MMHOOK</code>'s <code class="code" id="fz4kf2_75">Update</code> event of <code class="code" id="fz4kf2_76">PlayerControllerB</code>, which runs when the original <code class="code" id="fz4kf2_77">Update</code> method of <code class="code" id="fz4kf2_78">PlayerControllerB</code> runs.</p><p id="fz4kf2_36">If we want to undo our patch, we can simply do this:</p><div class="code-block" data-lang="csharp">
// Unsubscribe from event, undoing the patch
On.Player.Update -= MyPatch
</div><p id="fz4kf2_38">Do note however that hooking and unhooking isn't cheap performance wise, and therefore it isn't a great idea to e.g. unhook your patch method inside the patch method, as the game will have to wait for unhooking to finish.</p><p id="fz4kf2_39">In such a case, you could unhook on a thread other than the game's main thread, or avoid unhooking altogether by having a <code class="code" id="fz4kf2_79">boolean</code> to determine whether or not your custom logic should run.</p><aside class="prompt" data-type="warning" data-title="" id="fz4kf2_40"><p id="fz4kf2_80"><span class="control" id="fz4kf2_84">IMPORTANT</span></p><p id="fz4kf2_81">To make use of <code class="code" id="fz4kf2_85">MMHOOK</code> assemblies, you will need to reference them in your project. This can be simply done by e.g. adding the following to your <code class="code" id="fz4kf2_86">csproj</code> file:</p><div class="code-block" data-lang="csharp">
&lt;ItemGroup&gt;
    &lt;Reference Include=&quot;MMHOOK_Assembly-CSharp&quot;&gt;&lt;HintPath&gt;./my/path/to/MMHOOK_Assembly-CSharp.dll&lt;/HintPath&gt;&lt;/Reference&gt;
&lt;/ItemGroup&gt;
</div><p id="fz4kf2_83">You can find the <code class="code" id="fz4kf2_87">MMHOOK</code> files from the <code class="code" id="fz4kf2_88">.../BepInEx/plugins/MMHOOK/</code> directory if you have <a href="https://thunderstore.io/c/lethal-company/p/Evaisa/HookGenPatcher/" id="fz4kf2_89" data-external="true" rel="noopener noreferrer">AutoHookGenPatcher</a> installed.</p></aside><section class="chapter"><h3 id="basics-of-using-events-in-c" data-toc="basics-of-using-events-in-c">Basics of Using Events in C#</h3><p id="fz4kf2_90">In case events in C# are new to you, we'll go through the basics of how to work with them. <span class="control" id="fz4kf2_98">To subscribe to an event</span>, we use the addition assignment operator (<code class="code" id="fz4kf2_99">+=</code>). <span class="control" id="fz4kf2_100">To unsubscribe from an event</span>, we use the subtraction assignment operator (<code class="code" id="fz4kf2_101">-=</code>).</p><p id="fz4kf2_91">Our <span class="control" id="fz4kf2_102">event handler</span> goes to the right side of the operator, and is a method that takes in the arguments given by the event we are subscribing to. In our earlier example, we subscribed <code class="code" id="fz4kf2_103">MyPatch</code> to the <code class="code" id="fz4kf2_104">On.Player.Update</code> event. This event passes the original method <code class="code" id="fz4kf2_105">On.Player.orig_Update orig</code> and an instance of the object <code class="code" id="fz4kf2_106">Player self</code> as arguments.</p><p id="fz4kf2_92">Thankfully, we can let our IDE generate the method for us (<span class="emphasis" id="fz4kf2_107">from e.g. <code class="code" id="fz4kf2_108">quick fix</code>-&gt; <code class="code" id="fz4kf2_109">Generate Method 'MyPatch'</code> in Visual Studio Code</span>) so we don't need to define it ourselves. This will generate the the following method:</p><div class="code-block" data-lang="csharp">
private static void MyPatch(On.Player.orig_Update orig, Player self) {
    throw new NotImplementedException();
}
</div><p id="fz4kf2_94">However, currently this will just throw an exception and the original method will not run. Let's fix that:</p><div class="code-block" data-lang="csharp">
private static void MyPatch(On.Player.orig_Update orig, Player self) {
    orig(self);
}
</div><p id="fz4kf2_96">What we just did is call the original method <code class="code" id="fz4kf2_110">orig</code> with the arguments it takes, which is just <code class="code" id="fz4kf2_111">self</code>. If it had more arguments, we would also pass them in the <code class="code" id="fz4kf2_112">orig</code> call, e.g. <code class="code" id="fz4kf2_113">orig(self, arg2, arg3);</code>. The reason why <code class="code" id="fz4kf2_114">self</code> is an argument is because the method we are patching is not static meaning it has an instance, which is what <code class="code" id="fz4kf2_115">self</code> is.</p><p id="fz4kf2_97">With <code class="code" id="fz4kf2_116">self</code>, we can access and manipulate the variables of the class (script), which in this case would be an instance of <code class="code" id="fz4kf2_117">Player</code>. Now we have gone through the basics, and can move on to examples.</p></section><section class="chapter"><h3 id="example-patch-with-monomod" data-toc="example-patch-with-monomod">Example Patch With MonoMod</h3><p id="fz4kf2_118">A simple patch we can do is giving the player infinite health, so taking damage will be ineffective. Here we have hooked <code class="code" id="fz4kf2_122">Player</code>'s <code class="code" id="fz4kf2_123">Update</code> method which runs every frame. In the Hook, we run the original method, and then get the value of <code class="code" id="fz4kf2_124">ai</code> and check if it's false in an if statement. This is because the monsters also have the <code class="code" id="fz4kf2_125">Player</code> class attached to them, and the <code class="code" id="fz4kf2_126">ai</code> variable differentiates them. If it is false, we set the <code class="code" id="fz4kf2_127">Player.PlayerData.maxHealth</code> to 10000, and the <code class="code" id="fz4kf2_128">self.data.health</code> to the <code class="code" id="fz4kf2_129">Player.PlayerData.maxHealth</code>.</p><div class="code-block" data-lang="csharp">
private static void MyPatch(On.Player.orig_Update orig, Player self) {
    // Code here runs before the original method
    orig(self); // Call the original method with its argumetns
    // Code here runs after the original method

    // ai is a boolean field of Player which
    // is set to true if the class is attached to a monster
    if (!self.ai) {
        // Set the max health in player data
        Player.PlayerData.maxHealth = 10000;
        // Set the player's health to the max health
        self.data.health = Player.PlayerData.maxHealth;
    }
}
</div><p id="fz4kf2_120">Notice that patches will always apply for every instance of a class, so this code runs for every other plaeyr instance in your game. However, this patch will not truly affect other players' health, unless you are the host, even if you have this patch applied, since the player health is required to be updated on the server to do anything.</p><aside class="prompt" data-type="tip" data-title="" id="fz4kf2_121"><p id="fz4kf2_130"><span class="control" id="fz4kf2_132">TIP</span></p><p id="fz4kf2_131">See <a href="https://lethal.wiki/dev/fundamentals/patching-code/monomod-examples" id="fz4kf2_133" data-external="true" rel="noopener noreferrer">Patching Code With MonoMod -- Examples</a> from lethal.wiki for more examples and information about MonoMod usage, and see their unofficial <a href="https://lethal.wiki/dev/fundamentals/patching-code/monomod-documentation" id="fz4kf2_134" data-external="true" rel="noopener noreferrer">MonoMod Documentation</a> for more in-depth details on how things work!</p></aside></section></section><section class="chapter"><h2 id="harmony" data-toc="harmony">Harmony</h2><p id="fz4kf2_135">With Harmony, you need to follow certain rules to write your patches. You must specify the arguments you need in your patch methods, and they must be named correctly for them to be recognized as the correct ones. For example, the argument for the instance of an object must be named <code class="code" id="fz4kf2_138">__instance</code>.</p><p id="fz4kf2_136">For more information about Harmony, see the <a href="https://harmony.pardeike.net/articles/intro.html" id="fz4kf2_139" data-external="true" rel="noopener noreferrer">Harmony</a> or <a href="https://github.com/BepInEx/HarmonyX/wiki/Basic-usage" id="fz4kf2_140" data-external="true" rel="noopener noreferrer">HarmonyX</a> documentation.</p><section class="chapter"><h3 id="example-patch-with-harmony" data-toc="example-patch-with-harmony">Example Patch With Harmony</h3><p id="fz4kf2_141">We will now do the same patch for infinite health as we did in Harmony:</p><div class="code-block" data-lang="csharp">
using HarmonyLib;

// Define that this class is patching the Player class
[HarmonyPatch(typeof(Player))]
class PlayerPatch {
    // We use attributes to tell Harmony which method we are targeting
    [HarmonyPatch(nameof(Player.Update))]
    // We also specify that our patch method will run after the original method
    [HarmonyPostfix]
    private static void Player_Update(Player __instance) {
        if (!__instance.ai) {
            Player.PlayerData.maxHealth = 10000;
            __instance.data.health = Player.PlayerData.maxHealth;
        }
    }
}
</div></section></section><section class="chapter"><h2 id="conclusion" data-toc="conclusion">Conclusion</h2><p id="fz4kf2_143">We have now briefly gone through using MonoMod and Harmony for Patching code. Let's now quickly go through the reasons why one might prefer either tool:</p><p id="fz4kf2_144"><span class="control" id="fz4kf2_149">Why MonoMod</span></p><ul class="list _bullet" id="fz4kf2_145"><li class="list__item" id="fz4kf2_150"><p id="fz4kf2_153"><span class="control" id="fz4kf2_155">MonoMod.RuntimeDetour.HookGen's</span> <code class="code" id="fz4kf2_156">MMHOOK</code> assemblies make patching easy:</p><ul class="list _bullet" id="fz4kf2_154"><li class="list__item" id="fz4kf2_157"><p>Applying patches is <span class="control" id="fz4kf2_159">clean</span> and <span class="control" id="fz4kf2_160">explicit</span> (e.g. <code class="code" id="fz4kf2_161">On.Namespace.Type.Method += MyPatch;</code>)</p></li><li class="list__item" id="fz4kf2_158"><p>We can simply <span class="control" id="fz4kf2_162">autocomplete</span> our patch method's definition</p></li></ul></li><li class="list__item" id="fz4kf2_151"><p id="fz4kf2_163">A <span class="control" id="fz4kf2_164">single patch method</span> can contain code that runs <span class="control" id="fz4kf2_165">before and after</span> the original method</p></li><li class="list__item" id="fz4kf2_152"><p id="fz4kf2_166">MonoMod patching works with predictable rules, meanwhile Harmony has its own specific rules you have ot follow (e.g. special argument names)</p></li></ul><p id="fz4kf2_146"><span class="control" id="fz4kf2_167">Why Harmony</span></p><ul class="list _bullet" id="fz4kf2_147"><li class="list__item" id="fz4kf2_168"><p id="fz4kf2_170">You can register all your patches in a <span class="control" id="fz4kf2_171">single line</span></p></li><li class="list__item" id="fz4kf2_169"><p id="fz4kf2_172">Makes using the same patch method for multiple methods slightly easier</p><ul class="list _bullet" id="fz4kf2_173"><li class="list__item" id="fz4kf2_174"><p id="fz4kf2_175">This is due to how you can specify the arguments you want; you don't need to include every argument in the definition of a patch like with MonoMod's <span class="control" id="fz4kf2_177">Hooks</span>.</p><ul class="list _bullet" id="fz4kf2_176"><li class="list__item" id="fz4kf2_178"><p>With <span class="control" id="fz4kf2_179">MonoMod</span>, you would need to make an <span class="control" id="fz4kf2_180">ILHook</span> for this</p></li></ul></li></ul></li></ul><p id="fz4kf2_148">It is entirely up to you which one you should use. But remember: you aren't restricted to using only one of them; you can use whichever works the best in whatever situation.</p></section><div class="last-modified">Last modified: 12 October 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="reading-game-code.html" class="navigation-links__prev">Reading Game Code</a><a href="intermediate.html" class="navigation-links__next">Intermediate</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b419/app.js"></script></body></html>