# Patching Code

> **INFO**
>
> This tutorial is taken and adapted from the [Lethal Company Modding Wiki](https://lethal.wiki). For more resources refer to that.
>

## Introduction
When modding games, you will often need to make modifications to the original code. Thankfully, this is fairly easy thanks to **MonoMod** and **Harmony**. These allow us to things such as:

* **Replace and modify** original methods
* **Run our code before and/or after** the original methods

MonoMod and Harmony are incredibly powerful tools, and with them, we can do nearly anything we want. They differ in the ways they are used, and it really just comes up to preference which one you should use.

However, keep in mind that you aren't restricted to using only one of these tools, as the version of Harmony we are using is [HarmonyX](https://github.com/BepInEx/HarmonyX), which is Harmony built on top of **MonoMod** so there will not be any conflicts.

> **NOTE**
> 
> In this and the following articles, we use "patching" and "hooking" to refer to the act of running our code before and after the original method, or directly modifying the original method.
>

## MonoMod
> **INFO**
> 
> The version of **MonoMod** we use with BepInEx is considered **legacy**, which is important to know when looking up [MonoMod Documentation](https://lethal.wiki/dev/fundamentals/patching-code/monomod-documentation).
>

MonoMod is arguably easier to use than Harmony in most cases thanks to its ``MMHOOK`` assemblies generated by **MonoMod.RuntimeDetour.HookGen**.

If you've ever wondered what [AutoHookGenPatcher](https://thunderstore.io/c/content-warning/p/Hamunii/AutoHookGenPatcher/) is, it generates these files from its target assemblies using MonoMod's HookGen API. For example, ``Assembly-CSharp.dll`` is the assembly that contains most of the game's code, and HookGen generates a file from it called ``MMHOOK_Assembly-CSharp.dll``, which provides us an easy way to Hook any non-generic method as if it were an event.

To use these events, we can for example do the following:

```C#
// Subscribe to the event, applying our patch
On.Player.Update += MyPatch;
```

> **INFO**
> 
> ``Player`` is the class/script that controls all players in Content Warning. It is defined under the default namespace.
> 
> ``Update`` is a method which executes on every frame, which ``Player`` implements. This is a method provided by the [MonoBehaviour](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html) class in Unity.
> 
{style="note"}

> **TIP**
> 
> All ``MMHOOK`` Hooks are under the ``On`` and ``IL`` namespaces.
> The ``On`` namespace contains normal Hooks which allow running our code before and after the original method, while the ``IL`` namespace contains **ILHooks** which allow us to modify the original methods on the **IL** (or **CIL**) level, which is what C# compiles to.
> 
{style="tip"}

This will add our method ``MyPatch`` as an event handler for the ``MMHOOK``'s ``Update`` event of ``PlayerControllerB``, which runs when the original ``Update`` method of ``PlayerControllerB`` runs.

If we want to undo our patch, we can simply do this:
```C#
// Unsubscribe from event, undoing the patch
On.Player.Update -= MyPatch
```

Do note however that hooking and unhooking isn't cheap performance wise, and therefore it isn't a great idea to e.g. unhook your patch method inside the patch method, as the game will have to wait for unhooking to finish.

In such a case, you could unhook on a thread other than the game's main thread, or avoid unhooking altogether by having a ``boolean`` to determine whether or not your custom logic should run.

> **IMPORTANT**
> 
> To make use of ``MMHOOK`` assemblies, you will need to reference them in your project. This can be simply done by e.g. adding the following to your ``csproj`` file:
>
> ```C#
> <ItemGroup>
>     <Reference Include="MMHOOK_Assembly-CSharp"><HintPath>./my/path/to/MMHOOK_Assembly-CSharp.dll</HintPath></Reference>
> </ItemGroup>
> ```
> 
> You can find the ``MMHOOK`` files from the ``.../BepInEx/plugins/MMHOOK/`` directory if you have [AutoHookGenPatcher](https://thunderstore.io/c/lethal-company/p/Evaisa/HookGenPatcher/) installed.
> 
{style="warning"}

### Basics of Using Events in C#
In case events in C# are new to you, we'll go through the basics of how to work with them.
**To subscribe to an event**, we use the addition assignment operator (``+=``).
**To unsubscribe from an event**, we use the subtraction assignment operator (``-=``).

Our **event handler** goes to the right side of the operator, and is a method that takes in the arguments given by the event we are subscribing to. In our earlier example, we subscribed ``MyPatch`` to the ``On.Player.Update`` event. This event passes the original method ``On.Player.orig_Update orig`` and an instance of the object ``Player self`` as arguments.

Thankfully, we can let our IDE generate the method for us (_from e.g. ``quick fix`` -> ``Generate Method 'MyPatch'`` in Visual Studio Code_) so we don't need to define it ourselves. This will generate the the following method:

```C#
private static void MyPatch(On.Player.orig_Update orig, Player self) {
    throw new NotImplementedException();
}
```

However, currently this will just throw an exception and the original method will not run. Let's fix that:
```C#
private static void MyPatch(On.Player.orig_Update orig, Player self) {
    orig(self);
}
```

What we just did is call the original method ``orig`` with the arguments it takes, which is just ``self``. If it had more arguments, we would also pass them in the ``orig`` call, e.g. ``orig(self, arg2, arg3);``. The reason why ``self`` is an argument is because the method we are patching is not static meaning it has an instance, which is what ``self`` is.

With ``self``, we can access and manipulate the variables of the class (script), which in this case would be an instance of ``Player``. Now we have gone through the basics, and can move on to examples.

### Example Patch With MonoMod
A simple patch we can do is giving the player infinite health, so taking damage will be ineffective. Here we have hooked ``Player``'s ``Update`` method which runs every frame. In the Hook, we run the original method, and then get the value of ``ai`` and check if it's false in an if statement. This is because the monsters also have the ``Player`` class attached to them, and the ``ai`` variable differentiates them. If it is false, we set the ``Player.PlayerData.maxHealth`` to 10000, and the ``self.data.health`` to the ``Player.PlayerData.maxHealth``.
```C#
private static void MyPatch(On.Player.orig_Update orig, Player self) {
    // Code here runs before the original method
    orig(self); // Call the original method with its argumetns
    // Code here runs after the original method

    // ai is a boolean field of Player which
    // is set to true if the class is attached to a monster
    if (!self.ai) {
        // Set the max health in player data
        Player.PlayerData.maxHealth = 10000;
        // Set the player's health to the max health
        self.data.health = Player.PlayerData.maxHealth;
    }
}
```

Notice that patches will always apply for every instance of a class, so this code runs for every other plaeyr instance in your game. However, this patch will not truly affect other players' health, unless you are the host, even if you have this patch applied, since the player health is required to be updated on the server to do anything.

> **TIP**
> 
> See [Patching Code With MonoMod -- Examples](https://lethal.wiki/dev/fundamentals/patching-code/monomod-examples) from lethal.wiki for more examples and information about MonoMod usage, and see their unofficial [MonoMod Documentation](https://lethal.wiki/dev/fundamentals/patching-code/monomod-documentation) for more in-depth details on how things work!
>

## Harmony

With Harmony, you need to follow certain rules to write your patches. You must specify the arguments you need in your patch methods, and they must be named correctly for them to be recognized as the correct ones. For example, the argument for the instance of an object must be named ``__instance``.

For more information about Harmony, see the [Harmony](https://harmony.pardeike.net/articles/intro.html) or [HarmonyX](https://github.com/BepInEx/HarmonyX/wiki/Basic-usage) documentation.

### Example Patch With Harmony
We will now do the same patch for infinite health as we did in Harmony:

```C#
using HarmonyLib;

// Define that this class is patching the Player class
[HarmonyPatch(typeof(Player))]
class PlayerPatch {
    // We use attributes to tell Harmony which method we are targeting
    [HarmonyPatch(nameof(Player.Update))]
    // We also specify that our patch method will run after the original method
    [HarmonyPostfix]
    private static void Player_Update(Player __instance) {
        if (!__instance.ai) {
            Player.PlayerData.maxHealth = 10000;
            __instance.data.health = Player.PlayerData.maxHealth;
        }
    }
}
```

## Conclusion
We have now briefly gone through using MonoMod and Harmony for Patching code. Let's now quickly go through the reasons why one might prefer either tool:

**Why MonoMod**

* **MonoMod.RuntimeDetour.HookGen's** ``MMHOOK`` assemblies make patching easy:

    * Applying patches is **clean** and **explicit** (e.g. ``On.Namespace.Type.Method += MyPatch;``)
    * We can simply **autocomplete** our patch method's definition
* A **single patch method** can contain code that runs **before and after** the original method
* MonoMod patching works with predictable rules, meanwhile Harmony has its own specific rules you have ot follow (e.g. special argument names)

**Why Harmony**

* You can register all your patches in a **single line**
* Makes using the same patch method for multiple methods slightly easier

    * This is due to how you can specify the arguments you want; you don't need to include every argument in the definition of a patch like with MonoMod's **Hooks**.

        * With **MonoMod**, you would need to make an **ILHook** for this

It is entirely up to you which one you should use. But remember: you aren't restricted to using only one of them; you can use whichever works the best in whatever situation.